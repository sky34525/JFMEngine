<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Engine/Assets/Shaders/animal_fragment.glsl">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Engine/Assets/Shaders/animal_fragment.glsl" />
              <option name="updatedContent" value="#version 330 core&#10;&#10;out vec4 FragColor;&#10;&#10;// 从顶点着色器传入&#10;in vec3 v_FragPos;&#10;in vec3 v_Normal;&#10;in vec2 v_TexCoord;&#10;&#10;// 材质纹理&#10;uniform sampler2D u_DiffuseTexture;&#10;uniform sampler2D u_SpecularTexture;&#10;uniform sampler2D u_NormalTexture;&#10;uniform bool u_HasDiffuseTexture;&#10;uniform bool u_HasSpecularTexture;&#10;uniform bool u_HasNormalTexture;&#10;&#10;// 材质属性&#10;struct Material {&#10;    vec3 ambient;&#10;    vec3 diffuse;&#10;    vec3 specular;&#10;    float shininess;&#10;    float alpha;&#10;};&#10;uniform Material u_Material;&#10;&#10;// 方向光（太阳光）&#10;struct DirectionalLight {&#10;    vec3 direction;&#10;    vec3 ambient;&#10;    vec3 diffuse;&#10;    vec3 specular;&#10;};&#10;uniform DirectionalLight u_DirLight;&#10;&#10;// 点光源&#10;struct PointLight {&#10;    vec3 position;&#10;    vec3 ambient;&#10;    vec3 diffuse;&#10;    vec3 specular;&#10;    &#10;    float constant;&#10;    float linear;&#10;    float quadratic;&#10;};&#10;#define MAX_POINT_LIGHTS 4&#10;uniform PointLight u_PointLights[MAX_POINT_LIGHTS];&#10;uniform int u_NumPointLights;&#10;&#10;// 摄像机位置&#10;uniform vec3 u_ViewPos;&#10;&#10;// 计算方向光&#10;vec3 CalcDirLight(DirectionalLight light, vec3 normal, vec3 viewDir, vec3 diffuseColor, vec3 specularColor)&#10;{&#10;    vec3 lightDir = normalize(-light.direction);&#10;    &#10;    // 漫反射&#10;    float diff = max(dot(normal, lightDir), 0.0);&#10;    &#10;    // 镜面反射&#10;    vec3 reflectDir = reflect(-lightDir, normal);&#10;    float spec = pow(max(dot(viewDir, reflectDir), 0.0), u_Material.shininess);&#10;    &#10;    // 合并结果&#10;    vec3 ambient = light.ambient * diffuseColor;&#10;    vec3 diffuse = light.diffuse * diff * diffuseColor;&#10;    vec3 specular = light.specular * spec * specularColor;&#10;    &#10;    return (ambient + diffuse + specular);&#10;}&#10;&#10;// 计算点光源&#10;vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir, vec3 diffuseColor, vec3 specularColor)&#10;{&#10;    vec3 lightDir = normalize(light.position - fragPos);&#10;    &#10;    // 漫反射&#10;    float diff = max(dot(normal, lightDir), 0.0);&#10;    &#10;    // 镜面反射&#10;    vec3 reflectDir = reflect(-lightDir, normal);&#10;    float spec = pow(max(dot(viewDir, reflectDir), 0.0), u_Material.shininess);&#10;    &#10;    // 衰减计算&#10;    float distance = length(light.position - fragPos);&#10;    float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));&#10;    &#10;    // 合并结果&#10;    vec3 ambient = light.ambient * diffuseColor;&#10;    vec3 diffuse = light.diffuse * diff * diffuseColor;&#10;    vec3 specular = light.specular * spec * specularColor;&#10;    &#10;    ambient *= attenuation;&#10;    diffuse *= attenuation;&#10;    specular *= attenuation;&#10;    &#10;    return (ambient + diffuse + specular);&#10;}&#10;&#10;void main()&#10;{&#10;    // 法线处理&#10;    vec3 norm = normalize(v_Normal);&#10;    vec3 viewDir = normalize(u_ViewPos - v_FragPos);&#10;    &#10;    // 获取材质颜色&#10;    vec3 diffuseColor;&#10;    vec3 specularColor;&#10;    &#10;    if (u_HasDiffuseTexture) {&#10;        diffuseColor = texture(u_DiffuseTexture, v_TexCoord).rgb;&#10;    } else {&#10;        diffuseColor = u_Material.diffuse;&#10;    }&#10;    &#10;    if (u_HasSpecularTexture) {&#10;        specularColor = texture(u_SpecularTexture, v_TexCoord).rgb;&#10;    } else {&#10;        specularColor = u_Material.specular;&#10;    }&#10;    &#10;    // 法线贴图处理（如果有的话）&#10;    if (u_HasNormalTexture) {&#10;        // 简化的法线贴图实现&#10;        vec3 normalMap = texture(u_NormalTexture, v_TexCoord).rgb * 2.0 - 1.0;&#10;        // 这里应该使用TBN矩阵，但为了简化暂时直接使用&#10;        norm = normalize(norm + normalMap * 0.1);&#10;    }&#10;    &#10;    // 计算光照&#10;    vec3 result = vec3(0.0);&#10;    &#10;    // 方向光&#10;    result += CalcDirLight(u_DirLight, norm, viewDir, diffuseColor, specularColor);&#10;    &#10;    // 点光源&#10;    for (int i = 0; i &lt; u_NumPointLights &amp;&amp; i &lt; MAX_POINT_LIGHTS; i++) {&#10;        result += CalcPointLight(u_PointLights[i], norm, v_FragPos, viewDir, diffuseColor, specularColor);&#10;    }&#10;    &#10;    // 添加环境光&#10;    result += u_Material.ambient * diffuseColor;&#10;    &#10;    // 输出最终颜色&#10;    FragColor = vec4(result, u_Material.alpha);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Engine/Assets/Shaders/animal_vertex.glsl">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Engine/Assets/Shaders/animal_vertex.glsl" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Engine/Include/JFMEngine.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Engine/Include/JFMEngine.h" />
              <option name="updatedContent" value="//&#10;// JFMEngine.h - JFM引擎主头文件&#10;// 包含引擎的所有主要功能模块&#10;//&#10;&#10;#pragma once&#10;&#10;// 核心系统&#10;#include &quot;JFMEngine/Core/Core.h&quot;&#10;#include &quot;JFMEngine/Core/Application.h&quot;&#10;#include &quot;JFMEngine/Core/Layer.h&quot;&#10;#include &quot;JFMEngine/Core/LayerStack.h&quot;&#10;&#10;// 事件系统&#10;#include &quot;JFMEngine/Events/Event.h&quot;&#10;#include &quot;JFMEngine/Events/ApplicationEvent.h&quot;&#10;#include &quot;JFMEngine/Events/KeyEvent.h&quot;&#10;#include &quot;JFMEngine/Events/MouseEvent.h&quot;&#10;&#10;// 渲染系统&#10;#include &quot;JFMEngine/Renderer/Renderer.h&quot;&#10;#include &quot;JFMEngine/Renderer/Renderer3D.h&quot;&#10;#include &quot;JFMEngine/Renderer/RenderCommand.h&quot;&#10;#include &quot;JFMEngine/Renderer/Shader.h&quot;&#10;#include &quot;JFMEngine/Renderer/Buffer.h&quot;&#10;#include &quot;JFMEngine/Renderer/VertexArray.h&quot;&#10;#include &quot;JFMEngine/Renderer/Texture.h&quot;&#10;#include &quot;JFMEngine/Renderer/Material.h&quot;&#10;#include &quot;JFMEngine/Renderer/Mesh.h&quot;&#10;#include &quot;JFMEngine/Renderer/Model.h&quot;&#10;#include &quot;JFMEngine/Renderer/Camera.h&quot;&#10;#include &quot;JFMEngine/Renderer/Light.h&quot;&#10;&#10;// ECS系统&#10;#include &quot;JFMEngine/ECS/ECS.h&quot;&#10;#include &quot;JFMEngine/ECS/Entity.h&quot;&#10;#include &quot;JFMEngine/ECS/Component.h&quot;&#10;#include &quot;JFMEngine/ECS/Components.h&quot;&#10;#include &quot;JFMEngine/ECS/System.h&quot;&#10;#include &quot;JFMEngine/ECS/World.h&quot;&#10;#include &quot;JFMEngine/ECS/Systems/TransformSystem.h&quot;&#10;#include &quot;JFMEngine/ECS/Systems/RenderSystem.h&quot;&#10;&#10;// 场景系统&#10;#include &quot;JFMEngine/Scene/Scene.h&quot;&#10;#include &quot;JFMEngine/Scene/SceneFactory.h&quot;&#10;&#10;// 资源系统&#10;#include &quot;JFMEngine/Resources/ResourceManager.h&quot;&#10;&#10;// 工具类&#10;#include &quot;JFMEngine/Utils/Log.h&quot;&#10;&#10;// 数学库&#10;#include &lt;glm/glm.hpp&gt;&#10;#include &lt;glm/gtc/matrix_transform.hpp&gt;&#10;#include &lt;glm/gtc/type_ptr.hpp&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Engine/Include/JFMEngine/Scene/SceneImporter.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Engine/Include/JFMEngine/Scene/SceneImporter.h" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Engine/Include/JFMEngine/Utils/Log.inl">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Engine/Include/JFMEngine/Utils/Log.inl" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;spdlog/spdlog.h&gt;&#10;#include &lt;spdlog/fmt/fmt.h&gt;&#10;&#10;namespace JFM {&#10;&#10;// 核心日志方法模板实现&#10;template&lt;typename... Args&gt;&#10;void Log::CoreTrace(const std::string&amp; fmt, Args&amp;&amp;... args) {&#10;    s_CoreLogger-&gt;trace(fmt::runtime(fmt), std::forward&lt;Args&gt;(args)...);&#10;}&#10;&#10;template&lt;typename... Args&gt;&#10;void Log::CoreInfo(const std::string&amp; fmt, Args&amp;&amp;... args) {&#10;    s_CoreLogger-&gt;info(fmt::runtime(fmt), std::forward&lt;Args&gt;(args)...);&#10;}&#10;&#10;template&lt;typename... Args&gt;&#10;void Log::CoreWarn(const std::string&amp; fmt, Args&amp;&amp;... args) {&#10;    s_CoreLogger-&gt;warn(fmt::runtime(fmt), std::forward&lt;Args&gt;(args)...);&#10;}&#10;&#10;template&lt;typename... Args&gt;&#10;void Log::CoreError(const std::string&amp; fmt, Args&amp;&amp;... args) {&#10;    s_CoreLogger-&gt;error(fmt::runtime(fmt), std::forward&lt;Args&gt;(args)...);&#10;}&#10;&#10;// 客户端日志方法模板实现&#10;template&lt;typename... Args&gt;&#10;void Log::ClientTrace(const std::string&amp; fmt, Args&amp;&amp;... args) {&#10;    s_ClientLogger-&gt;trace(fmt::runtime(fmt), std::forward&lt;Args&gt;(args)...);&#10;}&#10;&#10;template&lt;typename... Args&gt;&#10;void Log::ClientInfo(const std::string&amp; fmt, Args&amp;&amp;... args) {&#10;    s_ClientLogger-&gt;info(fmt::runtime(fmt), std::forward&lt;Args&gt;(args)...);&#10;}&#10;&#10;template&lt;typename... Args&gt;&#10;void Log::ClientWarn(const std::string&amp; fmt, Args&amp;&amp;... args) {&#10;    s_ClientLogger-&gt;warn(fmt::runtime(fmt), std::forward&lt;Args&gt;(args)...);&#10;}&#10;&#10;template&lt;typename... Args&gt;&#10;void Log::ClientError(const std::string&amp; fmt, Args&amp;&amp;... args) {&#10;    s_ClientLogger-&gt;error(fmt::runtime(fmt), std::forward&lt;Args&gt;(args)...);&#10;}&#10;&#10;} // namespace JFM" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Engine/Include/JFMEngine/Utils/LogConfig.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Engine/Include/JFMEngine/Utils/LogConfig.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;string&gt;&#10;&#10;namespace spdlog {&#10;    namespace level {&#10;        enum level_enum;&#10;    }&#10;}&#10;&#10;namespace JFM {&#10;&#10;/**&#10; * @brief 日志系统配置&#10; */&#10;struct LogConfig {&#10;    // 日志级别 - 使用 int 存储，避免直接依赖 spdlog&#10;    int CoreLogLevel = 0;    // trace&#10;    int ClientLogLevel = 0;  // trace&#10;&#10;    // 输出配置&#10;    bool EnableConsoleOutput = true;&#10;    bool EnableFileOutput = true;&#10;    bool EnableColorOutput = true;&#10;&#10;    // 文件配置&#10;    std::string LogDirectory = &quot;logs&quot;;&#10;    std::string LogFileName = &quot;jfm_engine.log&quot;;&#10;    size_t MaxFileSize = 1048576 * 10; // 10MB&#10;    size_t MaxFiles = 3;&#10;&#10;    // 格式配置&#10;    std::string LogPattern = &quot;%^[%Y-%m-%d %H:%M:%S.%e] [%t] [%l] [%n]: %v%$&quot;;&#10;&#10;    // 性能配置&#10;    int FlushIntervalSeconds = 3;&#10;    int FlushLevel = 3; // error level&#10;&#10;    // 线程安全&#10;    bool MultiThreaded = true;&#10;};&#10;&#10;/**&#10; * @brief 高级日志系统配置工具&#10; */&#10;class LogConfigurator {&#10;public:&#10;    /**&#10;     * @brief 从配置文件加载配置&#10;     */&#10;    static LogConfig LoadFromFile(const std::string&amp; configPath);&#10;&#10;    /**&#10;     * @brief 获取默认配置&#10;     */&#10;    static LogConfig GetDefaultConfig();&#10;&#10;    /**&#10;     * @brief 获取发布版本配置（性能优化）&#10;     */&#10;    static LogConfig GetReleaseConfig();&#10;&#10;    /**&#10;     * @brief 获取调试版本配置（详细日志）&#10;     */&#10;    static LogConfig GetDebugConfig();&#10;};&#10;&#10;} // namespace JFM&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;string&gt;&#10;#include &lt;spdlog/spdlog.h&gt;&#10;&#10;namespace JFM {&#10;&#10;/**&#10; * @brief 日志系统配置&#10; */&#10;struct LogConfig {&#10;    // 日志级别&#10;    spdlog::level::level_enum CoreLogLevel = spdlog::level::trace;&#10;    spdlog::level::level_enum ClientLogLevel = spdlog::level::trace;&#10;    &#10;    // 输出配置&#10;    bool EnableConsoleOutput = true;&#10;    bool EnableFileOutput = true;&#10;    bool EnableColorOutput = true;&#10;    &#10;    // 文件配置&#10;    std::string LogDirectory = &quot;logs&quot;;&#10;    std::string LogFileName = &quot;jfm_engine.log&quot;;&#10;    size_t MaxFileSize = 1048576 * 10; // 10MB&#10;    size_t MaxFiles = 3;&#10;    &#10;    // 格式配置&#10;    std::string LogPattern = &quot;%^[%Y-%m-%d %H:%M:%S.%e] [%t] [%l] [%n]: %v%$&quot;;&#10;    &#10;    // 性能配置&#10;    int FlushIntervalSeconds = 3;&#10;    spdlog::level::level_enum FlushLevel = spdlog::level::err;&#10;    &#10;    // 线程安全&#10;    bool MultiThreaded = true;&#10;};&#10;&#10;/**&#10; * @brief 高级日志系统配置工具&#10; */&#10;class LogConfigurator {&#10;public:&#10;    /**&#10;     * @brief 从配置文件加载配置&#10;     */&#10;    static LogConfig LoadFromFile(const std::string&amp; configPath);&#10;&#10;    /**&#10;     * @brief 获取默认配置&#10;     */&#10;    static LogConfig GetDefaultConfig();&#10;&#10;    /**&#10;     * @brief 获取发布版本配置（性能优化）&#10;     */&#10;    static LogConfig GetReleaseConfig();&#10;&#10;    /**&#10;     * @brief 获取调试版本配置（详细日志）&#10;     */&#10;    static LogConfig GetDebugConfig();&#10;};&#10;&#10;} // namespace JFM" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Engine/Layers/Source/TestLayer.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Engine/Layers/Source/TestLayer.cpp" />
              <option name="originalContent" value="//&#10;// Created by kw on 25-7-24.&#10;// 示例图层实现&#10;//&#10;&#10;#include &quot;JFMEngine/Layers/TestLayer.h&quot;&#10;#include &quot;JFMEngine/Utils/Log.h&quot;&#10;#include &lt;glad/glad.h&gt;&#10;#include &lt;GLFW/glfw3.h&gt;&#10;#include &lt;cmath&gt;&#10;#include &lt;glm/glm.hpp&gt;&#10;#include &lt;glm/gtc/matrix_transform.hpp&gt;&#10;#include &quot;JFMEngine/Renderer/Camera.h&quot;&#10;&#10;namespace JFM {&#10;&#10;    TestLayer::TestLayer()&#10;        : Layer(&quot;TestLayer&quot;)&#10;    {&#10;        JFM_CORE_INFO(&quot;TestLayer 构造函数&quot;);&#10;    }&#10;&#10;    void TestLayer::OnAttach()&#10;    {&#10;        JFM_CORE_INFO(&quot;TestLayer 已附加到应用程序&quot;);&#10;    }&#10;&#10;    void TestLayer::OnDetach()&#10;    {&#10;        JFM_CORE_INFO(&quot;TestLayer 已从应用程序分离&quot;);&#10;    }&#10;&#10;    void TestLayer::OnUpdate()&#10;    {&#10;        // 清除屏幕&#10;        glClearColor(0.1f, 0.1f, 0.2f, 1.0f);&#10;        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);&#10;&#10;        // 3D立方体顶点数据（位置）&#10;        static float vertices[] = {&#10;            // 前面&#10;            -0.5f, -0.5f,  0.5f,&#10;             0.5f, -0.5f,  0.5f,&#10;             0.5f,  0.5f,  0.5f,&#10;            -0.5f,  0.5f,  0.5f,&#10;            // 后面&#10;            -0.5f, -0.5f, -0.5f,&#10;             0.5f, -0.5f, -0.5f,&#10;             0.5f,  0.5f, -0.5f,&#10;            -0.5f,  0.5f, -0.5f&#10;        };&#10;        static unsigned int indices[] = {&#10;            0, 1, 2, 2, 3, 0, // 前&#10;            1, 5, 6, 6, 2, 1, // 右&#10;            5, 4, 7, 7, 6, 5, // 后&#10;            4, 0, 3, 3, 7, 4, // 左&#10;            3, 2, 6, 6, 7, 3, // 上&#10;            4, 5, 1, 1, 0, 4  // 下&#10;        };&#10;        static unsigned int VAO = 0, VBO = 0, EBO = 0;&#10;        if (VAO == 0) {&#10;            glGenVertexArrays(1, &amp;VAO);&#10;            glGenBuffers(1, &amp;VBO);&#10;            glGenBuffers(1, &amp;EBO);&#10;            glBindVertexArray(VAO);&#10;            glBindBuffer(GL_ARRAY_BUFFER, VBO);&#10;            glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#10;            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);&#10;            glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);&#10;            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);&#10;            glEnableVertexAttribArray(0);&#10;            glBindVertexArray(0);&#10;        }&#10;        // 简单着色器（硬编码）&#10;        static unsigned int shaderProgram = 0;&#10;        if (shaderProgram == 0) {&#10;            const char* vertexShaderSource = R&quot;(&#10;                #version 410 core&#10;                layout(location = 0) in vec3 aPos;&#10;                uniform mat4 uMVP;&#10;                void main() {&#10;                    gl_Position = uMVP * vec4(aPos, 1.0);&#10;                }&#10;            )&quot;;&#10;            const char* fragmentShaderSource = R&quot;(&#10;                #version 410 core&#10;                out vec4 FragColor;&#10;                void main() {&#10;                    FragColor = vec4(0.2, 0.7, 0.9, 1.0);&#10;                }&#10;            )&quot;;&#10;            unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);&#10;            glShaderSource(vertexShader, 1, &amp;vertexShaderSource, nullptr);&#10;            glCompileShader(vertexShader);&#10;            unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);&#10;            glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, nullptr);&#10;            glCompileShader(fragmentShader);&#10;            shaderProgram = glCreateProgram();&#10;            glAttachShader(shaderProgram, vertexShader);&#10;            glAttachShader(shaderProgram, fragmentShader);&#10;            glLinkProgram(shaderProgram);&#10;            glDeleteShader(vertexShader);&#10;            glDeleteShader(fragmentShader);&#10;        }&#10;        // MVP矩阵（引入glm实现透视投影和摄像机视图）&#10;        static Camera camera(45.0f, 800.0f/600.0f, 0.1f, 100.0f);&#10;        // 可根据需要动态设置摄像机位置和旋转&#10;        // camera.SetPosition(glm::vec3(0, 0, 3));&#10;        // camera.SetRotation(0, 0);&#10;        float time = (float)glfwGetTime();&#10;        float angle = time;&#10;        glm::mat4 model = glm::rotate(glm::mat4(1.0f), angle, glm::vec3(0, 1, 0));&#10;        glm::mat4 view = camera.GetViewMatrix();&#10;        glm::mat4 proj = camera.GetProjectionMatrix();&#10;        glm::mat4 mvp = proj * view * model;&#10;        glUseProgram(shaderProgram);&#10;        int mvpLoc = glGetUniformLocation(shaderProgram, &quot;uMVP&quot;);&#10;        glUniformMatrix4fv(mvpLoc, 1, GL_FALSE, &amp;mvp[0][0]);&#10;        glBindVertexArray(VAO);&#10;        glEnable(GL_DEPTH_TEST);&#10;        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);&#10;        glBindVertexArray(0);&#10;        glUseProgram(0);&#10;    }&#10;&#10;    void TestLayer::OnImGuiRender()&#10;    {&#10;        // 在这里可以添加渲染逻辑&#10;        // 目前只是简单的清屏颜色变化&#10;        static float time = 0.0f;//通过静态变量来保持时间状态&#10;        time += 0.01f;&#10;&#10;        // 动态改变清屏颜色&#10;        float r = (sin(time) + 1.0f) * 0.5f;&#10;        float g = (sin(time + 2.0f) + 1.0f) * 0.5f;&#10;        float b = (sin(time + 4.0f) + 1.0f) * 0.5f;&#10;&#10;    }&#10;&#10;    void TestLayer::OnEvent(JFMengine::Event&amp; event)&#10;    {&#10;        JFMengine::EventDispatcher dispatcher(event);&#10;&#10;        // 分发事件到相应的处理函数&#10;        dispatcher.Dispatch&lt;JFMengine::KeyPressedEvent&gt;(&#10;            [this](JFMengine::KeyPressedEvent&amp; e) { return OnKeyPressed(e); });&#10;&#10;        dispatcher.Dispatch&lt;JFMengine::MouseButtonPressedEvent&gt;(&#10;            [this](JFMengine::MouseButtonPressedEvent&amp; e) { return OnMouseButtonPressed(e); });&#10;    }&#10;&#10;    bool TestLayer::OnKeyPressed(JFMengine::KeyPressedEvent&amp; e)&#10;    {&#10;        JFM_CORE_INFO(&quot;TestLayer: 按键按下 - 键码: &quot; + std::to_string(e.GetKeyCode()));&#10;&#10;        // 如果按下 ESC 键，可以做一些特殊处理&#10;        if (e.GetKeyCode() == 256) // GLFW_KEY_ESCAPE&#10;        {&#10;            JFM_CORE_INFO(&quot;TestLayer: ESC 键被按下&quot;);&#10;            return true; // 标记事件已处理，阻止传播&#10;        }&#10;&#10;        return false; // 不阻止事件传播&#10;    }&#10;&#10;    bool TestLayer::OnMouseButtonPressed(JFMengine::MouseButtonPressedEvent&amp; e)&#10;    {&#10;        JFM_CORE_INFO(&quot;TestLayer: 鼠标按钮按下 - 按钮: &quot; + std::to_string(e.GetMouseButton()));&#10;        return false; // 不阻止事件传播&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// Created by kw on 25-7-24.&#10;// 示例图层实现&#10;//&#10;&#10;#include &quot;JFMEngine/Layers/TestLayer.h&quot;&#10;#include &quot;JFMEngine/Utils/Log.h&quot;&#10;#include &lt;glad/glad.h&gt;&#10;#include &lt;GLFW/glfw3.h&gt;&#10;#include &lt;cmath&gt;&#10;#include &lt;glm/glm.hpp&gt;&#10;#include &lt;glm/gtc/matrix_transform.hpp&gt;&#10;#include &quot;JFMEngine/Renderer/Camera.h&quot;&#10;&#10;namespace JFM {&#10;&#10;    TestLayer::TestLayer()&#10;        : Layer(&quot;TestLayer&quot;)&#10;    {&#10;        JFM_CORE_INFO(&quot;TestLayer 构造函数&quot;);&#10;    }&#10;&#10;    void TestLayer::OnAttach()&#10;    {&#10;        JFM_CORE_INFO(&quot;TestLayer 已附加到应用程序&quot;);&#10;    }&#10;&#10;    void TestLayer::OnDetach()&#10;    {&#10;        JFM_CORE_INFO(&quot;TestLayer 已从应用程序分离&quot;);&#10;    }&#10;&#10;    void TestLayer::OnUpdate()&#10;    {&#10;        // 清除屏幕&#10;        glClearColor(0.1f, 0.1f, 0.2f, 1.0f);&#10;        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);&#10;&#10;        // 3D立方体顶点数据（位置）&#10;        static float vertices[] = {&#10;            // 前面&#10;            -0.5f, -0.5f,  0.5f,&#10;             0.5f, -0.5f,  0.5f,&#10;             0.5f,  0.5f,  0.5f,&#10;            -0.5f,  0.5f,  0.5f,&#10;            // 后面&#10;            -0.5f, -0.5f, -0.5f,&#10;             0.5f, -0.5f, -0.5f,&#10;             0.5f,  0.5f, -0.5f,&#10;            -0.5f,  0.5f, -0.5f&#10;        };&#10;        static unsigned int indices[] = {&#10;            0, 1, 2, 2, 3, 0, // 前&#10;            1, 5, 6, 6, 2, 1, // 右&#10;            5, 4, 7, 7, 6, 5, // 后&#10;            4, 0, 3, 3, 7, 4, // 左&#10;            3, 2, 6, 6, 7, 3, // 上&#10;            4, 5, 1, 1, 0, 4  // 下&#10;        };&#10;        static unsigned int VAO = 0, VBO = 0, EBO = 0;&#10;        if (VAO == 0) {&#10;            glGenVertexArrays(1, &amp;VAO);&#10;            glGenBuffers(1, &amp;VBO);&#10;            glGenBuffers(1, &amp;EBO);&#10;            glBindVertexArray(VAO);&#10;            glBindBuffer(GL_ARRAY_BUFFER, VBO);&#10;            glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#10;            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);&#10;            glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);&#10;            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);&#10;            glEnableVertexAttribArray(0);&#10;            glBindVertexArray(0);&#10;        }&#10;        // 简单着色器（硬编码）&#10;        static unsigned int shaderProgram = 0;&#10;        if (shaderProgram == 0) {&#10;            const char* vertexShaderSource = R&quot;(&#10;                #version 410 core&#10;                layout(location = 0) in vec3 aPos;&#10;                uniform mat4 uMVP;&#10;                void main() {&#10;                    gl_Position = uMVP * vec4(aPos, 1.0);&#10;                }&#10;            )&quot;;&#10;            const char* fragmentShaderSource = R&quot;(&#10;                #version 410 core&#10;                out vec4 FragColor;&#10;                void main() {&#10;                    FragColor = vec4(0.2, 0.7, 0.9, 1.0);&#10;                }&#10;            )&quot;;&#10;            unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);&#10;            glShaderSource(vertexShader, 1, &amp;vertexShaderSource, nullptr);&#10;            glCompileShader(vertexShader);&#10;            unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);&#10;            glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, nullptr);&#10;            glCompileShader(fragmentShader);&#10;            shaderProgram = glCreateProgram();&#10;            glAttachShader(shaderProgram, vertexShader);&#10;            glAttachShader(shaderProgram, fragmentShader);&#10;            glLinkProgram(shaderProgram);&#10;            glDeleteShader(vertexShader);&#10;            glDeleteShader(fragmentShader);&#10;        }&#10;        // MVP矩阵（引入glm实现透视投影和摄像机视图）&#10;        static Camera camera(45.0f, 800.0f/600.0f, 0.1f, 100.0f);&#10;        // 可根据需要动态设置摄像机位置和旋转&#10;        // camera.SetPosition(glm::vec3(0, 0, 3));&#10;        // camera.SetRotation(0, 0);&#10;        float time = (float)glfwGetTime();&#10;        float angle = time;&#10;        glm::mat4 model = glm::rotate(glm::mat4(1.0f), angle, glm::vec3(0, 1, 0));&#10;        glm::mat4 view = camera.GetViewMatrix();&#10;        glm::mat4 proj = camera.GetProjectionMatrix();&#10;        glm::mat4 mvp = proj * view * model;&#10;        glUseProgram(shaderProgram);&#10;        int mvpLoc = glGetUniformLocation(shaderProgram, &quot;uMVP&quot;);&#10;        glUniformMatrix4fv(mvpLoc, 1, GL_FALSE, &amp;mvp[0][0]);&#10;        glBindVertexArray(VAO);&#10;        glEnable(GL_DEPTH_TEST);&#10;        glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);&#10;        glBindVertexArray(0);&#10;        glUseProgram(0);&#10;    }&#10;&#10;    void TestLayer::OnImGuiRender()&#10;    {&#10;        // 在这里可以添加渲染逻辑&#10;        // 目前只是简单的清屏颜色变化&#10;        static float time = 0.0f;//通过静态变量来保持时间状态&#10;        time += 0.01f;&#10;&#10;        // 动态改变清屏颜色&#10;        float r = (sin(time) + 1.0f) * 0.5f;&#10;        float g = (sin(time + 2.0f) + 1.0f) * 0.5f;&#10;        float b = (sin(time + 4.0f) + 1.0f) * 0.5f;&#10;&#10;    }&#10;&#10;    void TestLayer::OnEvent(JFMengine::Event&amp; event)&#10;    {&#10;        // 摄像机交互控制示例：按W/S/A/D/Q/E移动摄像机，按方向键旋转摄像机&#10;        if (event.GetEventType() == JFMengine::EventType::KeyPressed) {&#10;            auto&amp; e = static_cast&lt;JFMengine::KeyPressedEvent&amp;&gt;(event);&#10;            static float moveSpeed = 0.05f;&#10;            static float rotSpeed = 2.0f;&#10;            if (e.GetKeyCode() == GLFW_KEY_W) camera.SetPosition(camera.GetPosition() + glm::vec3(0, 0, -moveSpeed));&#10;            if (e.GetKeyCode() == GLFW_KEY_S) camera.SetPosition(camera.GetPosition() + glm::vec3(0, 0, moveSpeed));&#10;            if (e.GetKeyCode() == GLFW_KEY_A) camera.SetPosition(camera.GetPosition() + glm::vec3(-moveSpeed, 0, 0));&#10;            if (e.GetKeyCode() == GLFW_KEY_D) camera.SetPosition(camera.GetPosition() + glm::vec3(moveSpeed, 0, 0));&#10;            if (e.GetKeyCode() == GLFW_KEY_Q) camera.SetPosition(camera.GetPosition() + glm::vec3(0, moveSpeed, 0));&#10;            if (e.GetKeyCode() == GLFW_KEY_E) camera.SetPosition(camera.GetPosition() + glm::vec3(0, -moveSpeed, 0));&#10;            if (e.GetKeyCode() == GLFW_KEY_UP) camera.SetRotation(camera.GetPitch() + rotSpeed, camera.GetYaw());&#10;            if (e.GetKeyCode() == GLFW_KEY_DOWN) camera.SetRotation(camera.GetPitch() - rotSpeed, camera.GetYaw());&#10;            if (e.GetKeyCode() == GLFW_KEY_LEFT) camera.SetRotation(camera.GetPitch(), camera.GetYaw() - rotSpeed);&#10;            if (e.GetKeyCode() == GLFW_KEY_RIGHT) camera.SetRotation(camera.GetPitch(), camera.GetYaw() + rotSpeed);&#10;        }&#10;&#10;        JFMengine::EventDispatcher dispatcher(event);&#10;&#10;        // 分发事件到相应的处理函数&#10;        dispatcher.Dispatch&lt;JFMengine::KeyPressedEvent&gt;(&#10;            [this](JFMengine::KeyPressedEvent&amp; e) { return OnKeyPressed(e); });&#10;&#10;        dispatcher.Dispatch&lt;JFMengine::MouseButtonPressedEvent&gt;(&#10;            [this](JFMengine::MouseButtonPressedEvent&amp; e) { return OnMouseButtonPressed(e); });&#10;    }&#10;&#10;    bool TestLayer::OnKeyPressed(JFMengine::KeyPressedEvent&amp; e)&#10;    {&#10;        JFM_CORE_INFO(&quot;TestLayer: 按键按下 - 键码: &quot; + std::to_string(e.GetKeyCode()));&#10;&#10;        // 如果按下 ESC 键，可以做一些特殊处理&#10;        if (e.GetKeyCode() == 256) // GLFW_KEY_ESCAPE&#10;        {&#10;            JFM_CORE_INFO(&quot;TestLayer: ESC 键被按下&quot;);&#10;            return true; // 标记事件已处理，阻止传播&#10;        }&#10;&#10;        return false; // 不阻止事件传播&#10;    }&#10;&#10;    bool TestLayer::OnMouseButtonPressed(JFMengine::MouseButtonPressedEvent&amp; e)&#10;    {&#10;        JFM_CORE_INFO(&quot;TestLayer: 鼠标按钮按下 - 按钮: &quot; + std::to_string(e.GetMouseButton()));&#10;        return false; // 不阻止事件传播&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Engine/Source/Utils/LogConfig.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Engine/Source/Utils/LogConfig.cpp" />
              <option name="originalContent" value="#include &quot;JFMEngine/Utils/LogConfig.h&quot;&#10;#include &lt;fstream&gt;&#10;#include &lt;iostream&gt;&#10;&#10;namespace JFM {&#10;&#10;// spdlog 日志级别映射：&#10;// 0 = trace, 1 = debug, 2 = info, 3 = warn, 4 = err, 5 = critical, 6 = off&#10;&#10;LogConfig LogConfigurator::LoadFromFile(const std::string&amp; configPath) {&#10;    LogConfig config = GetDefaultConfig();&#10;&#10;    // 这里可以实现从 JSON 或其他配置文件格式加载配置&#10;    // 为简化示例，直接返回默认配置&#10;    std::ifstream file(configPath);&#10;    if (!file.is_open()) {&#10;        std::cerr &lt;&lt; &quot;Warning: Could not open log config file: &quot; &lt;&lt; configPath&#10;                  &lt;&lt; &quot;. Using default configuration.&quot; &lt;&lt; std::endl;&#10;        return config;&#10;    }&#10;&#10;    // TODO: 实现具体的配置文件解析逻辑&#10;    file.close();&#10;    return config;&#10;}&#10;&#10;LogConfig LogConfigurator::GetDefaultConfig() {&#10;    LogConfig config;&#10;    config.CoreLogLevel = 2;    // info&#10;    config.ClientLogLevel = 2;  // info&#10;    config.EnableConsoleOutput = true;&#10;    config.EnableFileOutput = true;&#10;    config.EnableColorOutput = true;&#10;    config.LogDirectory = &quot;logs&quot;;&#10;    config.LogFileName = &quot;jfm_engine.log&quot;;&#10;    config.MaxFileSize = 1048576 * 10; // 10MB&#10;    config.MaxFiles = 3;&#10;    config.LogPattern = &quot;%^[%Y-%m-%d %H:%M:%S.%e] [%l] [%n]: %v%$&quot;;&#10;    config.FlushIntervalSeconds = 3;&#10;    config.FlushLevel = 4; // err&#10;    config.MultiThreaded = true;&#10;    return config;&#10;}&#10;&#10;LogConfig LogConfigurator::GetReleaseConfig() {&#10;    LogConfig config = GetDefaultConfig();&#10;    // 发布版本优化：减少日志级别，提高性能&#10;    config.CoreLogLevel = 3;    // warn&#10;    config.ClientLogLevel = 2;  // info&#10;    config.EnableFileOutput = false; // 发布版本可能不需要文件日志&#10;    config.FlushIntervalSeconds = 10; // 减少刷新频率&#10;    return config;&#10;}&#10;&#10;LogConfig LogConfigurator::GetDebugConfig() {&#10;    LogConfig config = GetDefaultConfig();&#10;    // 调试版本：最详细的日志&#10;    config.CoreLogLevel = 0;    // trace&#10;    config.ClientLogLevel = 0;  // trace&#10;    config.LogPattern = &quot;%^[%Y-%m-%d %H:%M:%S.%e] [%t] [%l] [%n] [%s:%#]: %v%$&quot;; // 包含源文件信息&#10;    config.FlushIntervalSeconds = 1; // 更频繁的刷新&#10;    config.FlushLevel = 1; // debug&#10;    return config;&#10;}&#10;&#10;} // namespace JFM&#10;" />
              <option name="updatedContent" value="#include &quot;JFMEngine/Utils/LogConfig.h&quot;&#10;#include &lt;fstream&gt;&#10;#include &lt;iostream&gt;&#10;&#10;namespace JFM {&#10;&#10;// spdlog 日志级别映射：&#10;// 0 = trace, 1 = debug, 2 = info, 3 = warn, 4 = err, 5 = critical, 6 = off&#10;&#10;LogConfig LogConfigurator::LoadFromFile(const std::string&amp; configPath) {&#10;    LogConfig config = GetDefaultConfig();&#10;&#10;    // 这里可以实现从 JSON 或其他配置文件格式加载配置&#10;    // 为简化示例，直接返回默认配置&#10;    std::ifstream file(configPath);&#10;    if (!file.is_open()) {&#10;        std::cerr &lt;&lt; &quot;Warning: Could not open log config file: &quot; &lt;&lt; configPath&#10;                  &lt;&lt; &quot;. Using default configuration.&quot; &lt;&lt; std::endl;&#10;        return config;&#10;    }&#10;&#10;    // TODO: 实现具体的配置文件解析逻辑&#10;    file.close();&#10;    return config;&#10;}&#10;&#10;LogConfig LogConfigurator::GetDefaultConfig() {&#10;    LogConfig config;&#10;    config.CoreLogLevel = 2;    // info&#10;    config.ClientLogLevel = 2;  // info&#10;    config.EnableConsoleOutput = true;&#10;    config.EnableFileOutput = true;&#10;    config.EnableColorOutput = true;&#10;    config.LogDirectory = &quot;logs&quot;;&#10;    config.LogFileName = &quot;jfm_engine.log&quot;;&#10;    config.MaxFileSize = 1048576 * 10; // 10MB&#10;    config.MaxFiles = 3;&#10;    config.LogPattern = &quot;%^[%Y-%m-%d %H:%M:%S.%e] [%l] [%n]: %v%$&quot;;&#10;    config.FlushIntervalSeconds = 3;&#10;    config.FlushLevel = 4; // err&#10;    config.MultiThreaded = true;&#10;    return config;&#10;}&#10;&#10;LogConfig LogConfigurator::GetReleaseConfig() {&#10;    LogConfig config = GetDefaultConfig();&#10;    // 发布版本优化：减少日志级别，提高性能&#10;    config.CoreLogLevel = 3;    // warn&#10;    config.ClientLogLevel = 2;  // info&#10;    config.EnableFileOutput = false; // 发布版本可能不需要文件日志&#10;    config.FlushIntervalSeconds = 10; // 减少刷新频率&#10;    return config;&#10;}&#10;&#10;LogConfig LogConfigurator::GetDebugConfig() {&#10;    LogConfig config = GetDefaultConfig();&#10;    // 调试版本：最详细的日志&#10;    config.CoreLogLevel = 0;    // trace&#10;    config.ClientLogLevel = 0;  // trace&#10;    config.LogPattern = &quot;%^[%Y-%m-%d %H:%M:%S.%e] [%t] [%l] [%n] [%s:%#]: %v%$&quot;; // 包含源文件信息&#10;    config.FlushIntervalSeconds = 1; // 更频繁的刷新&#10;    config.FlushLevel = 1; // debug&#10;    return config;&#10;}&#10;&#10;} // namespace JFM" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Examples/LogDemo/LogDemo.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Examples/LogDemo/LogDemo.cpp" />
              <option name="updatedContent" value="#include &quot;JFMEngine/Utils/Log.h&quot;&#10;#include &quot;JFMEngine/Utils/LogConfig.h&quot;&#10;#include &lt;thread&gt;&#10;#include &lt;chrono&gt;&#10;&#10;void DemonstrateBasicLogging() {&#10;    JFM_CORE_INFO(&quot;=== 基础日志功能演示 ===&quot;);&#10;    &#10;    // 不同日志级别&#10;    JFM_CORE_TRACE(&quot;这是一条 TRACE 级别的核心日志&quot;);&#10;    JFM_CORE_INFO(&quot;这是一条 INFO 级别的核心日志&quot;);&#10;    JFM_CORE_WARN(&quot;这是一条 WARN 级别的核心日志&quot;);&#10;    JFM_CORE_ERROR(&quot;这是一条 ERROR 级别的核心日志&quot;);&#10;    JFM_CORE_CRITICAL(&quot;这是一条 CRITICAL 级别的核心日志&quot;);&#10;    &#10;    // 客户端日志&#10;    JFM_INFO(&quot;=== 客户端日志功能演示 ===&quot;);&#10;    JFM_TRACE(&quot;应用程序 TRACE 日志&quot;);&#10;    JFM_INFO(&quot;应用程序 INFO 日志&quot;);&#10;    JFM_WARN(&quot;应用程序 WARN 日志&quot;);&#10;    JFM_ERROR(&quot;应用程序 ERROR 日志&quot;);&#10;    JFM_CRITICAL(&quot;应用程序 CRITICAL 日志&quot;);&#10;}&#10;&#10;void DemonstrateFormattedLogging() {&#10;    JFM_CORE_INFO(&quot;=== 格式化日志功能演示 ===&quot;);&#10;    &#10;    // 基本格式化&#10;    std::string username = &quot;JohnDoe&quot;;&#10;    int userLevel = 42;&#10;    JFM_CORE_INFO(&quot;用户 {} 登录，等级: {}&quot;, username, userLevel);&#10;    &#10;    // 数值格式化&#10;    float frameTime = 16.67f;&#10;    int fps = 60;&#10;    JFM_INFO(&quot;渲染统计 - 帧时间: {:.2f}ms, FPS: {}&quot;, frameTime, fps);&#10;    &#10;    // 容器和复杂对象&#10;    std::vector&lt;int&gt; values = {1, 2, 3, 4, 5};&#10;    JFM_CORE_TRACE(&quot;数组内容: [{}]&quot;, fmt::join(values, &quot;, &quot;));&#10;    &#10;    // 十六进制格式&#10;    uint32_t memoryAddress = 0xDEADBEEF;&#10;    JFM_CORE_DEBUG(&quot;内存地址: 0x{:08X}&quot;, memoryAddress);&#10;}&#10;&#10;void DemonstrateMultiThreadLogging() {&#10;    JFM_CORE_INFO(&quot;=== 多线程日志功能演示 ===&quot;);&#10;    &#10;    std::vector&lt;std::thread&gt; threads;&#10;    &#10;    // 创建多个线程进行日志输出&#10;    for (int i = 0; i &lt; 3; ++i) {&#10;        threads.emplace_back([i]() {&#10;            for (int j = 0; j &lt; 5; ++j) {&#10;                JFM_INFO(&quot;线程 {} 输出日志 #{}&quot;, i, j);&#10;                std::this_thread::sleep_for(std::chrono::milliseconds(100));&#10;            }&#10;        });&#10;    }&#10;    &#10;    // 等待所有线程完成&#10;    for (auto&amp; thread : threads) {&#10;        if (thread.joinable()) {&#10;            thread.join();&#10;        }&#10;    }&#10;    &#10;    JFM_CORE_INFO(&quot;多线程日志演示完成&quot;);&#10;}&#10;&#10;void DemonstrateCustomConfiguration() {&#10;    JFM_CORE_INFO(&quot;=== 自定义配置演示 ===&quot;);&#10;    &#10;    // 关闭当前日志系统&#10;    JFM::Log::Shutdown();&#10;    &#10;    // 创建自定义配置&#10;    JFM::LogConfig customConfig = JFM::LogConfigurator::GetDefaultConfig();&#10;    customConfig.LogPattern = &quot;%^[%H:%M:%S] [%n] [%l]: %v%$&quot;; // 简化格式&#10;    customConfig.EnableFileOutput = false; // 只输出到控制台&#10;    customConfig.CoreLogLevel = spdlog::level::warn; // 只显示警告级别以上&#10;    &#10;    // 使用自定义配置重新初始化&#10;    JFM::Log::InitWithConfig(customConfig);&#10;    &#10;    JFM_CORE_TRACE(&quot;这条 TRACE 日志不会显示&quot;);&#10;    JFM_CORE_INFO(&quot;这条 INFO 日志不会显示&quot;);&#10;    JFM_CORE_WARN(&quot;这条 WARN 日志会显示&quot;);&#10;    JFM_CORE_ERROR(&quot;这条 ERROR 日志会显示&quot;);&#10;}&#10;&#10;void DemonstrateAssertions() {&#10;    JFM_CORE_INFO(&quot;=== 断言日志演示 ===&quot;);&#10;    &#10;    int value = 10;&#10;    &#10;    // 这个断言会通过（不会输出日志）&#10;    JFM_CORE_ASSERT(value &gt; 5, &quot;值应该大于5，实际值: {}&quot;, value);&#10;    &#10;    // 这个断言会失败（会输出错误日志）&#10;    JFM_CORE_ASSERT(value &gt; 20, &quot;值应该大于20，但实际值是: {}&quot;, value);&#10;    &#10;    // 客户端断言&#10;    std::string filename = &quot;config.json&quot;;&#10;    bool fileExists = false; // 模拟文件不存在&#10;    JFM_ASSERT(fileExists, &quot;配置文件不存在: {}&quot;, filename);&#10;}&#10;&#10;int main() {&#10;    try {&#10;        // 初始化日志系统&#10;        JFM::Log::Init();&#10;        &#10;        JFM_CORE_INFO(&quot;JFM Engine 日志系统演示程序启动&quot;);&#10;        JFM_INFO(&quot;欢迎使用 JFM Engine 日志系统！&quot;);&#10;        &#10;        // 演示各种功能&#10;        DemonstrateBasicLogging();&#10;        std::this_thread::sleep_for(std::chrono::milliseconds(500));&#10;        &#10;        DemonstrateFormattedLogging();&#10;        std::this_thread::sleep_for(std::chrono::milliseconds(500));&#10;        &#10;        DemonstrateMultiThreadLogging();&#10;        std::this_thread::sleep_for(std::chrono::milliseconds(500));&#10;        &#10;        DemonstrateAssertions();&#10;        std::this_thread::sleep_for(std::chrono::milliseconds(500));&#10;        &#10;        DemonstrateCustomConfiguration();&#10;        &#10;        JFM_CORE_INFO(&quot;演示程序结束&quot;);&#10;        &#10;        // 正常关闭日志系统&#10;        JFM::Log::Shutdown();&#10;        &#10;    } catch (const std::exception&amp; ex) {&#10;        std::cerr &lt;&lt; &quot;程序执行出错: &quot; &lt;&lt; ex.what() &lt;&lt; std::endl;&#10;        return -1;&#10;    }&#10;    &#10;    return 0;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Examples/LogDemo/SimpleLogDemo.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Examples/LogDemo/SimpleLogDemo.cpp" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Examples/ModelLoadingDemo/ModelLoadingDemo.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Examples/ModelLoadingDemo/ModelLoadingDemo.cpp" />
              <option name="updatedContent" value="//&#10;// ModelLoadingDemo.cpp - Assimp模型加载演示&#10;// 展示如何使用Assimp库加载3D模型&#10;//&#10;&#10;#include &lt;JFMEngine/JFMEngine.h&gt;&#10;#include &quot;JFMEngine/Renderer/Model.h&quot;&#10;#include &quot;JFMEngine/Scene/SceneFactory.h&quot;&#10;#include &lt;glm/gtc/matrix_transform.hpp&gt;&#10;&#10;class ModelLoadingDemo : public JFM::Layer {&#10;public:&#10;    ModelLoadingDemo() : Layer(&quot;Model Loading Demo&quot;) {}&#10;&#10;    void OnAttach() override {&#10;        JFM_INFO(&quot;Model Loading Demo Layer attached&quot;);&#10;&#10;        // 初始化日志系统&#10;        JFM::Log::Initialize();&#10;        JFM_INFO(&quot;Log system initialized&quot;);&#10;&#10;        // 初始化场景工厂&#10;        JFM::SceneFactory::Initialize();&#10;&#10;        // 创建场景&#10;        m_Scene = std::make_shared&lt;JFM::Scene&gt;(&quot;Model Loading Scene&quot;);&#10;        m_Scene-&gt;Initialize();&#10;&#10;        // 设置场景&#10;        SetupScene();&#10;&#10;        JFM_INFO(&quot;Model loading demo initialized&quot;);&#10;    }&#10;&#10;    void OnDetach() override {&#10;        JFM::SceneFactory::Shutdown();&#10;        JFM_INFO(&quot;Model Loading Demo Layer detached&quot;);&#10;    }&#10;&#10;    void OnUpdate(float ts) override {&#10;        // 旋转模型&#10;        if (m_LoadedModel) {&#10;            m_ModelRotation += ts * 45.0f; // 每秒旋转45度&#10;            glm::mat4 transform = glm::rotate(glm::mat4(1.0f), &#10;                                            glm::radians(m_ModelRotation), &#10;                                            glm::vec3(0, 1, 0));&#10;            m_LoadedModel-&gt;SetTransform(transform);&#10;        }&#10;&#10;        // 更新场景&#10;        if (m_Scene) {&#10;            JFM::SceneManager::GetInstance().Update(ts);&#10;        }&#10;    }&#10;&#10;    void OnRender() override {&#10;        // 渲染场景&#10;        if (m_Scene) {&#10;            JFM::SceneManager::GetInstance().Render();&#10;        }&#10;&#10;        // 如果有加载的模型，直接渲染它（作为备选方案）&#10;        if (m_LoadedModel &amp;&amp; m_Shader) {&#10;            m_LoadedModel-&gt;Draw(m_Shader);&#10;        }&#10;    }&#10;&#10;    void OnEvent(JFM::Event&amp; event) override {&#10;        if (event.GetEventType() == JFM::EventType::KeyPressed) {&#10;            JFM::KeyPressedEvent&amp; keyEvent = static_cast&lt;JFM::KeyPressedEvent&amp;&gt;(event);&#10;            HandleKeyPress(keyEvent.GetKeyCode());&#10;        }&#10;    }&#10;&#10;private:&#10;    void SetupScene() {&#10;        auto world = m_Scene-&gt;GetWorld();&#10;&#10;        // 创建相机&#10;        m_Camera = JFM::SceneFactory::CreateDebugCamera(world, &quot;Model Camera&quot;);&#10;        auto&amp; cameraTransform = world-&gt;GetComponent&lt;JFM::ECS::TransformComponent&gt;(m_Camera);&#10;        cameraTransform.Position = glm::vec3(0.0f, 2.0f, 5.0f);&#10;        cameraTransform.Rotation = glm::angleAxis(glm::radians(-15.0f), glm::vec3(1, 0, 0));&#10;        m_Scene-&gt;SetActiveCamera(m_Camera);&#10;&#10;        // 创建基础光源&#10;        auto light = JFM::SceneFactory::CreateDirectionalLight(world, glm::vec3(-0.5f, -1.0f, -0.3f));&#10;&#10;        // 尝试加载一些常见的模型文件格式&#10;        LoadTestModels();&#10;&#10;        JFM_INFO(&quot;Scene setup completed&quot;);&#10;    }&#10;&#10;    void LoadTestModels() {&#10;        // 尝试加载一些测试模型&#10;        std::vector&lt;std::string&gt; testPaths = {&#10;            &quot;assets/models/test.obj&quot;,&#10;            &quot;assets/models/cube.obj&quot;, &#10;            &quot;models/test.fbx&quot;,&#10;            &quot;test.obj&quot;,&#10;            &quot;../assets/models/test.obj&quot;&#10;        };&#10;&#10;        for (const auto&amp; path : testPaths) {&#10;            JFM_INFO(&quot;Attempting to load model: {}&quot;, path);&#10;            &#10;            try {&#10;                auto model = std::make_shared&lt;JFM::Model&gt;(path);&#10;                if (model &amp;&amp; model-&gt;GetMeshCount() &gt; 0) {&#10;                    m_LoadedModel = model;&#10;                    JFM_INFO(&quot;Successfully loaded model: {} with {} meshes&quot;, path, model-&gt;GetMeshCount());&#10;                    break;&#10;                } else {&#10;                    JFM_WARN(&quot;Failed to load model or model is empty: {}&quot;, path);&#10;                }&#10;            } catch (const std::exception&amp; e) {&#10;                JFM_WARN(&quot;Exception loading model {}: {}&quot;, path, e.what());&#10;            }&#10;        }&#10;&#10;        if (!m_LoadedModel) {&#10;            JFM_WARN(&quot;No models could be loaded. The demo will show an empty scene.&quot;);&#10;            JFM_INFO(&quot;To test model loading, place a .obj, .fbx, .dae, or .gltf file in one of these locations:&quot;);&#10;            for (const auto&amp; path : testPaths) {&#10;                JFM_INFO(&quot;  - {}&quot;, path);&#10;            }&#10;        }&#10;&#10;        // 创建一个简单的着色器用于模型渲染（如果需要）&#10;        // m_Shader = JFM::Shader::Create(&quot;assets/shaders/model.vert&quot;, &quot;assets/shaders/model.frag&quot;);&#10;    }&#10;&#10;    void HandleKeyPress(int keyCode) {&#10;        switch (keyCode) {&#10;            case JFM::Key::R: // 重新加载模型&#10;                JFM_INFO(&quot;Reloading models...&quot;);&#10;                LoadTestModels();&#10;                break;&#10;            case JFM::Key::Space: // 暂停/恢复旋转&#10;                m_RotationPaused = !m_RotationPaused;&#10;                JFM_INFO(&quot;Model rotation: {}&quot;, m_RotationPaused ? &quot;PAUSED&quot; : &quot;RESUMED&quot;);&#10;                break;&#10;        }&#10;    }&#10;&#10;private:&#10;    std::shared_ptr&lt;JFM::Scene&gt; m_Scene;&#10;    JFM::ECS::Entity m_Camera = JFM::ECS::NULL_ENTITY;&#10;    std::shared_ptr&lt;JFM::Model&gt; m_LoadedModel;&#10;    std::shared_ptr&lt;JFM::Shader&gt; m_Shader;&#10;    &#10;    float m_ModelRotation = 0.0f;&#10;    bool m_RotationPaused = false;&#10;};&#10;&#10;// 应用程序类&#10;class ModelLoadingApp : public JFM::Application {&#10;public:&#10;    ModelLoadingApp() {&#10;        PushLayer(std::shared_ptr&lt;JFM::Layer&gt;(new ModelLoadingDemo()));&#10;    }&#10;&#10;    ~ModelLoadingApp() = default;&#10;};&#10;&#10;// 客户端入口点&#10;JFM::Application* JFM::CreateApplication() {&#10;    return new ModelLoadingApp();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Examples/ModelTestUtility/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Examples/ModelTestUtility/CMakeLists.txt" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.20)&#10;&#10;# ModelTestUtility 项目&#10;project(ModelTestUtility)&#10;&#10;# 设置 C++ 标准&#10;set(CMAKE_CXX_STANDARD 20)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;# 添加可执行文件&#10;add_executable(ModelTestUtility&#10;    ModelTestUtility.cpp&#10;)&#10;&#10;# 链接JFM引擎库&#10;target_link_libraries(ModelTestUtility PRIVATE&#10;    JFMEngine&#10;)&#10;&#10;# 包含目录&#10;target_include_directories(ModelTestUtility PRIVATE&#10;    ../../Engine/Include&#10;)&#10;&#10;# 设置输出目录&#10;set_target_properties(ModelTestUtility PROPERTIES&#10;    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Examples/ModelTestUtility/ModelTestUtility.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Examples/ModelTestUtility/ModelTestUtility.cpp" />
              <option name="originalContent" value="//&#10;// ModelTestUtility.cpp - 模型测试工具&#10;// 用于快速测试res/model目录中的FBX文件&#10;//&#10;&#10;#include &lt;JFMEngine/JFMEngine.h&gt;&#10;#include &quot;JFMEngine/Renderer/Model.h&quot;&#10;#include &quot;JFMEngine/Animation/Animation.h&quot;&#10;#include &lt;filesystem&gt;&#10;#include &lt;iostream&gt;&#10;&#10;class ModelTestLayer : public JFM::Layer {&#10;public:&#10;    ModelTestLayer() : Layer(&quot;Model Test&quot;) {}&#10;&#10;    void OnAttach() override {&#10;        JFM_INFO(&quot;Model Test Layer attached&quot;);&#10;        JFM::Log::Initialize();&#10;&#10;        // 扫描并测试所有模型文件&#10;        ScanAndTestModels();&#10;    }&#10;&#10;private:&#10;    void ScanAndTestModels() {&#10;        std::string modelDir = &quot;res/model&quot;;&#10;&#10;        JFM_INFO(&quot;=== 扫描模型目录: {} ===&quot;, modelDir);&#10;&#10;        if (!std::filesystem::exists(modelDir)) {&#10;            JFM_ERROR(&quot;模型目录不存在: {}&quot;, modelDir);&#10;            return;&#10;        }&#10;&#10;        // 遍历目录中的所有文件&#10;        for (const auto&amp; entry : std::filesystem::directory_iterator(modelDir)) {&#10;            if (entry.is_regular_file()) {&#10;                std::string filePath = entry.path().string();&#10;                std::string extension = entry.path().extension().string();&#10;&#10;                // 检查是否是支持的3D模型格式&#10;                if (IsSupportedFormat(extension)) {&#10;                    JFM_INFO(&quot;\n--- 测试模型: {} ---&quot;, filePath);&#10;                    TestModel(filePath);&#10;                } else {&#10;                    JFM_INFO(&quot;跳过不支持的文件: {}&quot;, filePath);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    bool IsSupportedFormat(const std::string&amp; extension) {&#10;        std::string ext = extension;&#10;        std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);&#10;&#10;        return ext == &quot;.fbx&quot; || ext == &quot;.obj&quot; || ext == &quot;.dae&quot; ||&#10;               ext == &quot;.gltf&quot; || ext == &quot;.glb&quot; || ext == &quot;.3ds&quot; ||&#10;               ext == &quot;.blend&quot; || ext == &quot;.x&quot; || ext == &quot;.md5mesh&quot;;&#10;    }&#10;&#10;    void TestModel(const std::string&amp; filePath) {&#10;        try {&#10;            auto model = std::make_shared&lt;JFM::Model&gt;(filePath);&#10;&#10;            if (!model) {&#10;                JFM_ERROR(&quot;❌ 模型创建失败&quot;);&#10;                return;&#10;            }&#10;&#10;            // 基本信息&#10;            JFM_INFO(&quot;✅ 模型加载成功!&quot;);&#10;            JFM_INFO(&quot;   网格数量: {}&quot;, model-&gt;GetMeshCount());&#10;&#10;            // 检查动画&#10;            if (model-&gt;HasAnimations()) {&#10;                const auto&amp; animations = model-&gt;GetAnimationClips();&#10;                JFM_INFO(&quot; 动画信息:&quot;);&#10;                JFM_INFO(&quot;   动画数量: {}&quot;, animations.size());&#10;&#10;                for (size_t i = 0; i &lt; animations.size(); ++i) {&#10;                    auto clip = animations[i];&#10;                    float duration = clip-&gt;GetDuration() / clip-&gt;GetTicksPerSecond();&#10;                    JFM_INFO(&quot;   [{}] '{}' - 时长: {:.2f}秒&quot;,&#10;                             i, clip-&gt;GetName(), duration);&#10;                }&#10;&#10;                // 测试动画播放&#10;                JFM_INFO(&quot; 测试动画播放...&quot;);&#10;                model-&gt;PlayAnimation(0);&#10;                model-&gt;SetAnimationLoop(true);&#10;                JFM_INFO(&quot;   ✅ 动画播放测试成功&quot;);&#10;&#10;            } else {&#10;                JFM_INFO(&quot;ℹ️  该模型没有动画数据&quot;);&#10;            }&#10;&#10;            // 网格详细信息&#10;            const auto&amp; meshes = model-&gt;GetMeshes();&#10;            JFM_INFO(&quot; 网格详细信息:&quot;);&#10;            for (size_t i = 0; i &lt; meshes.size(); ++i) {&#10;                auto mesh = meshes[i];&#10;                JFM_INFO(&quot;   网格[{}]: {} 顶点, {} 索引, {} 纹理&quot;,&#10;                         i, mesh-&gt;Vertices.size(), mesh-&gt;Indices.size(), mesh-&gt;Textures.size());&#10;&#10;                // 纹理信息&#10;                if (!mesh-&gt;Textures.empty()) {&#10;                    JFM_INFO(&quot;   纹理类型:&quot;);&#10;                    for (const auto&amp; texture : mesh-&gt;Textures) {&#10;                        JFM_INFO(&quot;     - {}&quot;, texture-&gt;GetType());&#10;                    }&#10;                }&#10;            }&#10;&#10;        } catch (const std::exception&amp; e) {&#10;            JFM_ERROR(&quot;❌ 模型测试异常: {}&quot;, e.what());&#10;        }&#10;    }&#10;};&#10;&#10;class ModelTestApp : public JFM::Application {&#10;public:&#10;    ModelTestApp() {&#10;        PushLayer(std::shared_ptr&lt;JFM::Layer&gt;(new ModelTestLayer()));&#10;    }&#10;};&#10;&#10;JFM::Application* JFM::CreateApplication() {&#10;    return new ModelTestApp();&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// ModelTestUtility.cpp - 模型测试工具&#10;// 用于快速测试res/model目录中的FBX文件&#10;//&#10;&#10;#include &lt;JFMEngine/JFMEngine.h&gt;&#10;#include &quot;JFMEngine/Renderer/Model.h&quot;&#10;#include &quot;JFMEngine/Animation/Animation.h&quot;&#10;#include &lt;filesystem&gt;&#10;#include &lt;iostream&gt;&#10;&#10;class ModelTestLayer : public JFM::Layer {&#10;public:&#10;    ModelTestLayer() : Layer(&quot;Model Test&quot;) {}&#10;&#10;    void OnAttach() override {&#10;        JFM_INFO(&quot;Model Test Layer attached&quot;);&#10;        JFM::Log::Initialize();&#10;&#10;        // 扫描并测试所有模型文件&#10;        ScanAndTestModels();&#10;    }&#10;&#10;private:&#10;    void ScanAndTestModels() {&#10;        // 尝试多个可能的模型目录路径&#10;        std::vector&lt;std::string&gt; possiblePaths = {&#10;            &quot;res/model&quot;,           // 如果从项目根目录运行&#10;            &quot;../res/model&quot;,        // 如果从cmake-build-debug运行&#10;            &quot;../../res/model&quot;,     // 如果从更深的目录运行&#10;            &quot;./res/model&quot;          // 当前目录&#10;        };&#10;        &#10;        std::string modelDir;&#10;        bool foundDir = false;&#10;        &#10;        // 查找存在的目录&#10;        for (const auto&amp; path : possiblePaths) {&#10;            if (std::filesystem::exists(path)) {&#10;                modelDir = path;&#10;                foundDir = true;&#10;                break;&#10;            }&#10;        }&#10;        &#10;        if (!foundDir) {&#10;            JFM_ERROR(&quot;找不到模型目录，尝试了以下路径:&quot;);&#10;            for (const auto&amp; path : possiblePaths) {&#10;                JFM_ERROR(&quot;  - {}&quot;, path);&#10;            }&#10;            return;&#10;        }&#10;        &#10;        JFM_INFO(&quot;=== 扫描模型目录: {} ===&quot;, modelDir);&#10;        &#10;        // 遍历目录中的所有文件&#10;        for (const auto&amp; entry : std::filesystem::directory_iterator(modelDir)) {&#10;            if (entry.is_regular_file()) {&#10;                std::string filePath = entry.path().string();&#10;                std::string extension = entry.path().extension().string();&#10;                &#10;                // 检查是否是支持的3D模型格式&#10;                if (IsSupportedFormat(extension)) {&#10;                    JFM_INFO(&quot;\n--- 测试模型: {} ---&quot;, filePath);&#10;                    TestModel(filePath);&#10;                } else {&#10;                    JFM_INFO(&quot;跳过不支持的文件: {}&quot;, filePath);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    bool IsSupportedFormat(const std::string&amp; extension) {&#10;        std::string ext = extension;&#10;        std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);&#10;&#10;        return ext == &quot;.fbx&quot; || ext == &quot;.obj&quot; || ext == &quot;.dae&quot; ||&#10;               ext == &quot;.gltf&quot; || ext == &quot;.glb&quot; || ext == &quot;.3ds&quot; ||&#10;               ext == &quot;.blend&quot; || ext == &quot;.x&quot; || ext == &quot;.md5mesh&quot;;&#10;    }&#10;&#10;    void TestModel(const std::string&amp; filePath) {&#10;        try {&#10;            auto model = std::make_shared&lt;JFM::Model&gt;(filePath);&#10;&#10;            if (!model) {&#10;                JFM_ERROR(&quot;❌ 模型创建失败&quot;);&#10;                return;&#10;            }&#10;&#10;            // 基本信息&#10;            JFM_INFO(&quot;✅ 模型加载成功!&quot;);&#10;            JFM_INFO(&quot;   网格数量: {}&quot;, model-&gt;GetMeshCount());&#10;&#10;            // 检查动画&#10;            if (model-&gt;HasAnimations()) {&#10;                const auto&amp; animations = model-&gt;GetAnimationClips();&#10;                JFM_INFO(&quot; 动画信息:&quot;);&#10;                JFM_INFO(&quot;   动画数量: {}&quot;, animations.size());&#10;&#10;                for (size_t i = 0; i &lt; animations.size(); ++i) {&#10;                    auto clip = animations[i];&#10;                    float duration = clip-&gt;GetDuration() / clip-&gt;GetTicksPerSecond();&#10;                    JFM_INFO(&quot;   [{}] '{}' - 时长: {:.2f}秒&quot;,&#10;                             i, clip-&gt;GetName(), duration);&#10;                }&#10;&#10;                // 测试动画播放&#10;                JFM_INFO(&quot; 测试动画播放...&quot;);&#10;                model-&gt;PlayAnimation(0);&#10;                model-&gt;SetAnimationLoop(true);&#10;                JFM_INFO(&quot;   ✅ 动画播放测试成功&quot;);&#10;&#10;            } else {&#10;                JFM_INFO(&quot;ℹ️  该模型没有动画数据&quot;);&#10;            }&#10;&#10;            // 网格详细信息&#10;            const auto&amp; meshes = model-&gt;GetMeshes();&#10;            JFM_INFO(&quot; 网格详细信息:&quot;);&#10;            for (size_t i = 0; i &lt; meshes.size(); ++i) {&#10;                auto mesh = meshes[i];&#10;                JFM_INFO(&quot;   网格[{}]: {} 顶点, {} 索引, {} 纹理&quot;,&#10;                         i, mesh-&gt;Vertices.size(), mesh-&gt;Indices.size(), mesh-&gt;Textures.size());&#10;&#10;                // 纹理信息&#10;                if (!mesh-&gt;Textures.empty()) {&#10;                    JFM_INFO(&quot;   纹理类型:&quot;);&#10;                    for (const auto&amp; texture : mesh-&gt;Textures) {&#10;                        JFM_INFO(&quot;     - {}&quot;, texture-&gt;GetType());&#10;                    }&#10;                }&#10;            }&#10;&#10;        } catch (const std::exception&amp; e) {&#10;            JFM_ERROR(&quot;❌ 模型测试异常: {}&quot;, e.what());&#10;        }&#10;    }&#10;};&#10;&#10;class ModelTestApp : public JFM::Application {&#10;public:&#10;    ModelTestApp() {&#10;        PushLayer(std::shared_ptr&lt;JFM::Layer&gt;(new ModelTestLayer()));&#10;    }&#10;};&#10;&#10;JFM::Application* JFM::CreateApplication() {&#10;    return new ModelTestApp();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Examples/SimpleModelViewer/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Examples/SimpleModelViewer/CMakeLists.txt" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.20)&#10;&#10;# SimpleModelViewer 项目&#10;project(SimpleModelViewer)&#10;&#10;# 设置 C++ 标准&#10;set(CMAKE_CXX_STANDARD 20)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;&#10;# 添加可执行文件&#10;add_executable(SimpleModelViewer&#10;    SimpleModelViewer.cpp&#10;)&#10;&#10;# 链接JFM引擎库&#10;target_link_libraries(SimpleModelViewer PRIVATE&#10;    JFMEngine&#10;)&#10;&#10;# 包含目录&#10;target_include_directories(SimpleModelViewer PRIVATE&#10;    ../../Engine/Include&#10;)&#10;&#10;# 设置输出目录&#10;set_target_properties(SimpleModelViewer PROPERTIES&#10;    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Examples/SimpleModelViewer/SimpleModelViewer.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Examples/SimpleModelViewer/SimpleModelViewer.cpp" />
              <option name="originalContent" value="//&#10;// SimpleModelViewer.cpp - 简单的模型查看器&#10;// 专门用于测试FBX模型的基本渲染&#10;//&#10;&#10;#include &lt;JFMEngine/JFMEngine.h&gt;&#10;#include &quot;JFMEngine/Renderer/Model.h&quot;&#10;#include &quot;JFMEngine/Animation/Animation.h&quot;&#10;#include &lt;glm/gtc/matrix_transform.hpp&gt;&#10;#include &lt;filesystem&gt;&#10;&#10;class SimpleModelViewer : public JFM::Layer {&#10;public:&#10;    SimpleModelViewer() : Layer(&quot;Simple Model Viewer&quot;) {}&#10;&#10;    void OnAttach() override {&#10;        JFM_INFO(&quot;Simple Model Viewer attached&quot;);&#10;        JFM::Log::Initialize();&#10;&#10;        // 设置OpenGL状态&#10;        glEnable(GL_DEPTH_TEST);&#10;        glEnable(GL_CULL_FACE);&#10;        glClearColor(0.2f, 0.3f, 0.4f, 1.0f); // 设置背景色为蓝灰色而不是黑色&#10;&#10;        // 加载模型&#10;        LoadModel();&#10;&#10;        // 设置相机&#10;        SetupCamera();&#10;&#10;        JFM_INFO(&quot;Simple Model Viewer initialized&quot;);&#10;    }&#10;&#10;    void OnUpdate(float deltaTime) override {&#10;        // 更新模型动画&#10;        if (m_Model) {&#10;            m_Model-&gt;Update(deltaTime);&#10;        }&#10;&#10;        // 更新相机旋转&#10;        m_CameraAngle += deltaTime * 0.5f;&#10;        UpdateCamera();&#10;    }&#10;&#10;    void OnRender() override {&#10;        // 清屏&#10;        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);&#10;&#10;        // 设置视口&#10;        int width, height;&#10;        auto window = glfwGetCurrentContext();&#10;        glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;        glViewport(0, 0, width, height);&#10;&#10;        if (m_Model) {&#10;            // 设置模型变换矩阵&#10;            glm::mat4 model = glm::mat4(1.0f);&#10;            model = glm::scale(model, glm::vec3(1.0f)); // 确保模型大小合适&#10;            m_Model-&gt;SetTransform(model);&#10;&#10;            // 使用简单的固定功能管线渲染（如果支持）&#10;            SetupLighting();&#10;            SetupMatrices();&#10;&#10;            // 渲染模型&#10;            m_Model-&gt;Draw(nullptr);&#10;        } else {&#10;            // 如果没有模型，绘制一个简单的三角形测试&#10;            DrawTestTriangle();&#10;        }&#10;    }&#10;&#10;    void OnEvent(JFM::Event&amp; event) override {&#10;        if (event.GetEventType() == JFM::EventType::KeyPressed) {&#10;            JFM::KeyPressedEvent&amp; keyEvent = static_cast&lt;JFM::KeyPressedEvent&amp;&gt;(event);&#10;            HandleKeyPress(keyEvent.GetKeyCode());&#10;        }&#10;    }&#10;&#10;private:&#10;    void LoadModel() {&#10;        // 查找模型文件&#10;        std::vector&lt;std::string&gt; possiblePaths = {&#10;            &quot;../res/model/blackcat.fbx&quot;,&#10;            &quot;res/model/blackcat.fbx&quot;,&#10;            &quot;../../res/model/blackcat.fbx&quot;&#10;        };&#10;&#10;        for (const auto&amp; path : possiblePaths) {&#10;            if (std::filesystem::exists(path)) {&#10;                JFM_INFO(&quot;Loading model from: {}&quot;, path);&#10;                try {&#10;                    m_Model = std::make_shared&lt;JFM::Model&gt;(path);&#10;                    if (m_Model &amp;&amp; m_Model-&gt;GetMeshCount() &gt; 0) {&#10;                        JFM_INFO(&quot;✅ Model loaded successfully!&quot;);&#10;                        JFM_INFO(&quot;   Meshes: {}&quot;, m_Model-&gt;GetMeshCount());&#10;&#10;                        // 如果有动画，播放第一个&#10;                        if (m_Model-&gt;HasAnimations()) {&#10;                            const auto&amp; animations = m_Model-&gt;GetAnimationClips();&#10;                            JFM_INFO(&quot;   Animations: {}&quot;, animations.size());&#10;                            m_Model-&gt;PlayAnimation(0);&#10;                            m_Model-&gt;SetAnimationLoop(true);&#10;                            JFM_INFO(&quot;   Playing: {}&quot;, animations[0]-&gt;GetName());&#10;                        }&#10;                        return;&#10;                    }&#10;                } catch (const std::exception&amp; e) {&#10;                    JFM_ERROR(&quot;Failed to load model {}: {}&quot;, path, e.what());&#10;                }&#10;            }&#10;        }&#10;&#10;        JFM_WARN(&quot;No model could be loaded, will show test triangle&quot;);&#10;    }&#10;&#10;    void SetupCamera() {&#10;        m_CameraPosition = glm::vec3(0.0f, 2.0f, 5.0f);&#10;        m_CameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);&#10;        m_CameraUp = glm::vec3(0.0f, 1.0f, 0.0f);&#10;    }&#10;&#10;    void UpdateCamera() {&#10;        // 相机绕模型旋转&#10;        float radius = 5.0f;&#10;        m_CameraPosition = glm::vec3(&#10;            cos(m_CameraAngle) * radius,&#10;            2.0f,&#10;            sin(m_CameraAngle) * radius&#10;        );&#10;    }&#10;&#10;    void SetupLighting() {&#10;        // 启用简单的光照&#10;        glEnable(GL_LIGHTING);&#10;        glEnable(GL_LIGHT0);&#10;&#10;        // 设置光源位置&#10;        GLfloat lightPos[] = {2.0f, 4.0f, 2.0f, 1.0f};&#10;        glLightfv(GL_LIGHT0, GL_POSITION, lightPos);&#10;&#10;        // 设置光源颜色&#10;        GLfloat lightColor[] = {1.0f, 1.0f, 1.0f, 1.0f};&#10;        glLightfv(GL_LIGHT0, GL_DIFFUSE, lightColor);&#10;        glLightfv(GL_LIGHT0, GL_SPECULAR, lightColor);&#10;&#10;        // 设置环境光&#10;        GLfloat ambientLight[] = {0.3f, 0.3f, 0.3f, 1.0f};&#10;        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambientLight);&#10;    }&#10;&#10;    void SetupMatrices() {&#10;        // 设置投影矩阵&#10;        glMatrixMode(GL_PROJECTION);&#10;        glLoadIdentity();&#10;&#10;        int width, height;&#10;        auto window = glfwGetCurrentContext();&#10;        glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;&#10;        if (height &gt; 0) {&#10;            float aspect = (float)width / (float)height;&#10;            // 使用gluPerspective等效函数&#10;            float fovy = 45.0f;&#10;            float zNear = 0.1f;&#10;            float zFar = 100.0f;&#10;&#10;            float f = 1.0f / tan(fovy * M_PI / 360.0f);&#10;            glm::mat4 proj = glm::mat4(0.0f);&#10;            proj[0][0] = f / aspect;&#10;            proj[1][1] = f;&#10;            proj[2][2] = (zFar + zNear) / (zNear - zFar);&#10;            proj[2][3] = -1.0f;&#10;            proj[3][2] = (2.0f * zFar * zNear) / (zNear - zFar);&#10;&#10;            glLoadMatrixf(&amp;proj[0][0]);&#10;        }&#10;&#10;        // 设置模型视图矩阵&#10;        glMatrixMode(GL_MODELVIEW);&#10;        glLoadIdentity();&#10;&#10;        // gluLookAt等效&#10;        glm::mat4 view = glm::lookAt(m_CameraPosition, m_CameraTarget, m_CameraUp);&#10;        glLoadMatrixf(&amp;view[0][0]);&#10;    }&#10;&#10;    void DrawTestTriangle() {&#10;        // 绘制一个彩色三角形作为测试&#10;        glDisable(GL_LIGHTING);&#10;        glBegin(GL_TRIANGLES);&#10;&#10;        glColor3f(1.0f, 0.0f, 0.0f); // 红色&#10;        glVertex3f(0.0f, 1.0f, 0.0f);&#10;&#10;        glColor3f(0.0f, 1.0f, 0.0f); // 绿色&#10;        glVertex3f(-1.0f, -1.0f, 0.0f);&#10;&#10;        glColor3f(0.0f, 0.0f, 1.0f); // 蓝色&#10;        glVertex3f(1.0f, -1.0f, 0.0f);&#10;&#10;        glEnd();&#10;        glEnable(GL_LIGHTING);&#10;    }&#10;&#10;    void HandleKeyPress(int keyCode) {&#10;        switch (keyCode) {&#10;            case JFM::Key::Space:&#10;                if (m_Model &amp;&amp; m_Model-&gt;HasAnimations()) {&#10;                    auto animator = m_Model-&gt;GetAnimator();&#10;                    if (animator &amp;&amp; animator-&gt;IsPlaying()) {&#10;                        m_Model-&gt;PauseAnimation();&#10;                        JFM_INFO(&quot;Animation paused&quot;);&#10;                    } else {&#10;                        m_Model-&gt;PlayAnimation(0);&#10;                        JFM_INFO(&quot;Animation resumed&quot;);&#10;                    }&#10;                }&#10;                break;&#10;&#10;            case JFM::Key::N:&#10;                if (m_Model &amp;&amp; m_Model-&gt;HasAnimations()) {&#10;                    const auto&amp; animations = m_Model-&gt;GetAnimationClips();&#10;                    m_CurrentAnimIndex = (m_CurrentAnimIndex + 1) % animations.size();&#10;                    m_Model-&gt;PlayAnimation(m_CurrentAnimIndex);&#10;                    JFM_INFO(&quot;Switched to animation: {}&quot;, animations[m_CurrentAnimIndex]-&gt;GetName());&#10;                }&#10;                break;&#10;        }&#10;    }&#10;&#10;private:&#10;    std::shared_ptr&lt;JFM::Model&gt; m_Model;&#10;    glm::vec3 m_CameraPosition;&#10;    glm::vec3 m_CameraTarget;&#10;    glm::vec3 m_CameraUp;&#10;    float m_CameraAngle = 0.0f;&#10;    int m_CurrentAnimIndex = 0;&#10;};&#10;&#10;class SimpleModelViewerApp : public JFM::Application {&#10;public:&#10;    SimpleModelViewerApp() {&#10;        PushLayer(std::shared_ptr&lt;JFM::Layer&gt;(new SimpleModelViewer()));&#10;    }&#10;};&#10;&#10;JFM::Application* JFM::CreateApplication() {&#10;    return new SimpleModelViewerApp();&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// SimpleModelViewer.cpp - 简单的模型查看器&#10;// 专门用于测试FBX模型的基本渲染&#10;//&#10;&#10;#include &lt;JFMEngine/JFMEngine.h&gt;&#10;#include &quot;JFMEngine/Renderer/Model.h&quot;&#10;#include &quot;JFMEngine/Animation/Animation.h&quot;&#10;#include &lt;glm/gtc/matrix_transform.hpp&gt;&#10;#include &lt;filesystem&gt;&#10;#include &lt;glad/glad.h&gt;  // 添加OpenGL函数声明&#10;#include &lt;GLFW/glfw3.h&gt; // 添加GLFW函数声明&#10;&#10;class SimpleModelViewer : public JFM::Layer {&#10;public:&#10;    SimpleModelViewer() : Layer(&quot;Simple Model Viewer&quot;) {}&#10;&#10;    void OnAttach() override {&#10;        JFM_INFO(&quot;Simple Model Viewer attached&quot;);&#10;        JFM::Log::Initialize();&#10;&#10;        // 设置OpenGL状态&#10;        glEnable(GL_DEPTH_TEST);&#10;        glEnable(GL_CULL_FACE);&#10;        glClearColor(0.2f, 0.3f, 0.4f, 1.0f); // 设置背景色为蓝灰色而不是黑色&#10;&#10;        // 加载模型&#10;        LoadModel();&#10;&#10;        // 设置相机&#10;        SetupCamera();&#10;&#10;        JFM_INFO(&quot;Simple Model Viewer initialized&quot;);&#10;    }&#10;&#10;    void OnUpdate(float deltaTime) override {&#10;        // 更新模型动画&#10;        if (m_Model) {&#10;            m_Model-&gt;Update(deltaTime);&#10;        }&#10;&#10;        // 更新相机旋转&#10;        m_CameraAngle += deltaTime * 0.5f;&#10;        UpdateCamera();&#10;    }&#10;&#10;    void OnRender() override {&#10;        // 清屏&#10;        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);&#10;&#10;        // 设置视口&#10;        int width, height;&#10;        auto window = glfwGetCurrentContext();&#10;        glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;        glViewport(0, 0, width, height);&#10;&#10;        if (m_Model) {&#10;            // 设置模型变换矩阵&#10;            glm::mat4 model = glm::mat4(1.0f);&#10;            model = glm::scale(model, glm::vec3(1.0f)); // 确保模型大小合适&#10;            m_Model-&gt;SetTransform(model);&#10;&#10;            // 使用简单的固定功能管线渲染（如果支持）&#10;            SetupLighting();&#10;            SetupMatrices();&#10;&#10;            // 渲染模型&#10;            m_Model-&gt;Draw(nullptr);&#10;        } else {&#10;            // 如果没有模型，绘制一个简单的三角形测试&#10;            DrawTestTriangle();&#10;        }&#10;    }&#10;&#10;    void OnEvent(JFM::Event&amp; event) override {&#10;        if (event.GetEventType() == JFM::EventType::KeyPressed) {&#10;            JFM::KeyPressedEvent&amp; keyEvent = static_cast&lt;JFM::KeyPressedEvent&amp;&gt;(event);&#10;            HandleKeyPress(keyEvent.GetKeyCode());&#10;        }&#10;    }&#10;&#10;private:&#10;    void LoadModel() {&#10;        // 查找模型文件&#10;        std::vector&lt;std::string&gt; possiblePaths = {&#10;            &quot;../res/model/blackcat.fbx&quot;,&#10;            &quot;res/model/blackcat.fbx&quot;,&#10;            &quot;../../res/model/blackcat.fbx&quot;&#10;        };&#10;&#10;        for (const auto&amp; path : possiblePaths) {&#10;            if (std::filesystem::exists(path)) {&#10;                JFM_INFO(&quot;Loading model from: {}&quot;, path);&#10;                try {&#10;                    m_Model = std::make_shared&lt;JFM::Model&gt;(path);&#10;                    if (m_Model &amp;&amp; m_Model-&gt;GetMeshCount() &gt; 0) {&#10;                        JFM_INFO(&quot;✅ Model loaded successfully!&quot;);&#10;                        JFM_INFO(&quot;   Meshes: {}&quot;, m_Model-&gt;GetMeshCount());&#10;&#10;                        // 如果有动画，播放第一个&#10;                        if (m_Model-&gt;HasAnimations()) {&#10;                            const auto&amp; animations = m_Model-&gt;GetAnimationClips();&#10;                            JFM_INFO(&quot;   Animations: {}&quot;, animations.size());&#10;                            m_Model-&gt;PlayAnimation(0);&#10;                            m_Model-&gt;SetAnimationLoop(true);&#10;                            JFM_INFO(&quot;   Playing: {}&quot;, animations[0]-&gt;GetName());&#10;                        }&#10;                        return;&#10;                    }&#10;                } catch (const std::exception&amp; e) {&#10;                    JFM_ERROR(&quot;Failed to load model {}: {}&quot;, path, e.what());&#10;                }&#10;            }&#10;        }&#10;&#10;        JFM_WARN(&quot;No model could be loaded, will show test triangle&quot;);&#10;    }&#10;&#10;    void SetupCamera() {&#10;        m_CameraPosition = glm::vec3(0.0f, 2.0f, 5.0f);&#10;        m_CameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);&#10;        m_CameraUp = glm::vec3(0.0f, 1.0f, 0.0f);&#10;    }&#10;&#10;    void UpdateCamera() {&#10;        // 相机绕模型旋转&#10;        float radius = 5.0f;&#10;        m_CameraPosition = glm::vec3(&#10;            cos(m_CameraAngle) * radius,&#10;            2.0f,&#10;            sin(m_CameraAngle) * radius&#10;        );&#10;    }&#10;&#10;    void SetupLighting() {&#10;        // 启用简单的光照&#10;        glEnable(GL_LIGHTING);&#10;        glEnable(GL_LIGHT0);&#10;&#10;        // 设置光源位置&#10;        GLfloat lightPos[] = {2.0f, 4.0f, 2.0f, 1.0f};&#10;        glLightfv(GL_LIGHT0, GL_POSITION, lightPos);&#10;&#10;        // 设置光源颜色&#10;        GLfloat lightColor[] = {1.0f, 1.0f, 1.0f, 1.0f};&#10;        glLightfv(GL_LIGHT0, GL_DIFFUSE, lightColor);&#10;        glLightfv(GL_LIGHT0, GL_SPECULAR, lightColor);&#10;&#10;        // 设置环境光&#10;        GLfloat ambientLight[] = {0.3f, 0.3f, 0.3f, 1.0f};&#10;        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambientLight);&#10;    }&#10;&#10;    void SetupMatrices() {&#10;        // 设置投影矩阵&#10;        glMatrixMode(GL_PROJECTION);&#10;        glLoadIdentity();&#10;&#10;        int width, height;&#10;        auto window = glfwGetCurrentContext();&#10;        glfwGetFramebufferSize(window, &amp;width, &amp;height);&#10;&#10;        if (height &gt; 0) {&#10;            float aspect = (float)width / (float)height;&#10;            // 使用gluPerspective等效函数&#10;            float fovy = 45.0f;&#10;            float zNear = 0.1f;&#10;            float zFar = 100.0f;&#10;&#10;            float f = 1.0f / tan(fovy * M_PI / 360.0f);&#10;            glm::mat4 proj = glm::mat4(0.0f);&#10;            proj[0][0] = f / aspect;&#10;            proj[1][1] = f;&#10;            proj[2][2] = (zFar + zNear) / (zNear - zFar);&#10;            proj[2][3] = -1.0f;&#10;            proj[3][2] = (2.0f * zFar * zNear) / (zNear - zFar);&#10;&#10;            glLoadMatrixf(&amp;proj[0][0]);&#10;        }&#10;&#10;        // 设置模型视图矩阵&#10;        glMatrixMode(GL_MODELVIEW);&#10;        glLoadIdentity();&#10;&#10;        // gluLookAt等效&#10;        glm::mat4 view = glm::lookAt(m_CameraPosition, m_CameraTarget, m_CameraUp);&#10;        glLoadMatrixf(&amp;view[0][0]);&#10;    }&#10;&#10;    void DrawTestTriangle() {&#10;        // 绘制一个彩色三角形作为测试&#10;        glDisable(GL_LIGHTING);&#10;        glBegin(GL_TRIANGLES);&#10;&#10;        glColor3f(1.0f, 0.0f, 0.0f); // 红色&#10;        glVertex3f(0.0f, 1.0f, 0.0f);&#10;&#10;        glColor3f(0.0f, 1.0f, 0.0f); // 绿色&#10;        glVertex3f(-1.0f, -1.0f, 0.0f);&#10;&#10;        glColor3f(0.0f, 0.0f, 1.0f); // 蓝色&#10;        glVertex3f(1.0f, -1.0f, 0.0f);&#10;&#10;        glEnd();&#10;        glEnable(GL_LIGHTING);&#10;    }&#10;&#10;    void HandleKeyPress(int keyCode) {&#10;        switch (keyCode) {&#10;            case JFM::Key::Space:&#10;                if (m_Model &amp;&amp; m_Model-&gt;HasAnimations()) {&#10;                    auto animator = m_Model-&gt;GetAnimator();&#10;                    if (animator &amp;&amp; animator-&gt;IsPlaying()) {&#10;                        m_Model-&gt;PauseAnimation();&#10;                        JFM_INFO(&quot;Animation paused&quot;);&#10;                    } else {&#10;                        m_Model-&gt;PlayAnimation(0);&#10;                        JFM_INFO(&quot;Animation resumed&quot;);&#10;                    }&#10;                }&#10;                break;&#10;&#10;            case JFM::Key::N:&#10;                if (m_Model &amp;&amp; m_Model-&gt;HasAnimations()) {&#10;                    const auto&amp; animations = m_Model-&gt;GetAnimationClips();&#10;                    m_CurrentAnimIndex = (m_CurrentAnimIndex + 1) % animations.size();&#10;                    m_Model-&gt;PlayAnimation(m_CurrentAnimIndex);&#10;                    JFM_INFO(&quot;Switched to animation: {}&quot;, animations[m_CurrentAnimIndex]-&gt;GetName());&#10;                }&#10;                break;&#10;        }&#10;    }&#10;&#10;private:&#10;    std::shared_ptr&lt;JFM::Model&gt; m_Model;&#10;    glm::vec3 m_CameraPosition;&#10;    glm::vec3 m_CameraTarget;&#10;    glm::vec3 m_CameraUp;&#10;    float m_CameraAngle = 0.0f;&#10;    int m_CurrentAnimIndex = 0;&#10;};&#10;&#10;class SimpleModelViewerApp : public JFM::Application {&#10;public:&#10;    SimpleModelViewerApp() {&#10;        PushLayer(std::shared_ptr&lt;JFM::Layer&gt;(new SimpleModelViewer()));&#10;    }&#10;};&#10;&#10;JFM::Application* JFM::CreateApplication() {&#10;    return new SimpleModelViewerApp();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Examples/TextureConfigDemo/TextureConfigDemo.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Examples/TextureConfigDemo/TextureConfigDemo.cpp" />
              <option name="updatedContent" value="//&#10;// TextureConfigDemo.cpp - 纹理配置系统演示&#10;// 展示如何使用外部配置文件来管理纹理参数&#10;//&#10;&#10;#include &lt;JFMEngine/JFMEngine.h&gt;&#10;#include &quot;JFMEngine/Renderer/TextureConfig.h&quot;&#10;#include &quot;JFMEngine/Renderer/Texture.h&quot;&#10;&#10;class TextureConfigDemo : public JFM::Layer {&#10;public:&#10;    TextureConfigDemo() : Layer(&quot;Texture Config Demo&quot;) {}&#10;&#10;    void OnAttach() override {&#10;        JFM_INFO(&quot;Texture Config Demo Layer attached&quot;);&#10;&#10;        // 初始化日志系统&#10;        JFM::Log::Initialize();&#10;        JFM_INFO(&quot;Log system initialized&quot;);&#10;&#10;        // 演示纹理配置系统&#10;        DemonstrateTextureConfig();&#10;    }&#10;&#10;    void OnDetach() override {&#10;        JFM_INFO(&quot;Texture Config Demo Layer detached&quot;);&#10;    }&#10;&#10;    void OnUpdate(float ts) override {&#10;        // 简单的更新逻辑&#10;    }&#10;&#10;    void OnRender() override {&#10;        // 简单的渲染逻辑&#10;    }&#10;&#10;private:&#10;    void DemonstrateTextureConfig() {&#10;        JFM_INFO(&quot;=== 纹理配置系统演示 ===&quot;);&#10;&#10;        auto&amp; configManager = JFM::TextureConfigManager::GetInstance();&#10;&#10;        // 1. 从配置文件加载纹理参数&#10;        std::string configPath = &quot;Engine/Assets/texture_config.txt&quot;;&#10;        bool loaded = configManager.LoadConfigFromFile(configPath);&#10;        JFM_INFO(&quot;配置文件加载结果: {}&quot;, loaded ? &quot;成功&quot; : &quot;失败&quot;);&#10;&#10;        // 2. 演示不同的纹理配置&#10;        DemonstrateTextureConfigurations(configManager);&#10;&#10;        // 3. 演示如何创建带配置的纹理&#10;        DemonstrateTextureCreation(configManager);&#10;&#10;        // 4. 演示动态注册配置&#10;        DemonstrateDynamicConfiguration(configManager);&#10;&#10;        // 5. 演示保存配置到文件&#10;        DemonstrateSaveConfiguration(configManager);&#10;    }&#10;&#10;    void DemonstrateTextureConfigurations(JFM::TextureConfigManager&amp; configManager) {&#10;        JFM_INFO(&quot;\n--- 内置纹理配置 ---&quot;);&#10;&#10;        // 显示所有预定义配置&#10;        std::vector&lt;std::string&gt; configNames = {&#10;            JFM::TextureConfigs::DEFAULT,&#10;            JFM::TextureConfigs::PIXEL_ART,&#10;            JFM::TextureConfigs::HIGH_QUALITY,&#10;            JFM::TextureConfigs::UI_TEXTURE,&#10;            JFM::TextureConfigs::NORMAL_MAP&#10;        };&#10;&#10;        for (const auto&amp; configName : configNames) {&#10;            if (configManager.HasConfig(configName)) {&#10;                auto spec = configManager.GetConfig(configName);&#10;                JFM_INFO(&quot;配置 '{}': MinFilter={}, MagFilter={}, WrapS={}, WrapT={}, GenerateMips={}&quot;,&#10;                         configName, &#10;                         static_cast&lt;int&gt;(spec.MinFilter),&#10;                         static_cast&lt;int&gt;(spec.MagFilter),&#10;                         static_cast&lt;int&gt;(spec.WrapS),&#10;                         static_cast&lt;int&gt;(spec.WrapT),&#10;                         spec.GenerateMips);&#10;            }&#10;        }&#10;    }&#10;&#10;    void DemonstrateTextureCreation(JFM::TextureConfigManager&amp; configManager) {&#10;        JFM_INFO(&quot;\n--- 使用配置创建纹理 ---&quot;);&#10;&#10;        // 模拟不同类型的纹理文件路径&#10;        std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; textureExamples = {&#10;            {&quot;assets/textures/diffuse.png&quot;, JFM::TextureConfigs::DEFAULT},&#10;            {&quot;assets/textures/sprite.png&quot;, JFM::TextureConfigs::PIXEL_ART},&#10;            {&quot;assets/textures/normal.png&quot;, JFM::TextureConfigs::NORMAL_MAP},&#10;            {&quot;assets/ui/button.png&quot;, JFM::TextureConfigs::UI_TEXTURE}&#10;        };&#10;&#10;        for (const auto&amp; [path, configName] : textureExamples) {&#10;            JFM_INFO(&quot;尝试使用配置 '{}' 创建纹理: {}&quot;, configName, path);&#10;            &#10;            // 注意：实际创建会失败因为文件不存在，但演示了API用法&#10;            try {&#10;                auto texture = configManager.CreateTextureWithConfig(path, configName);&#10;                if (texture) {&#10;                    JFM_INFO(&quot;  ✓ 纹理创建成功&quot;);&#10;                } else {&#10;                    JFM_WARN(&quot;  ✗ 纹理创建失败（文件可能不存在）&quot;);&#10;                }&#10;            } catch (const std::exception&amp; e) {&#10;                JFM_WARN(&quot;  ✗ 异常: {}&quot;, e.what());&#10;            }&#10;        }&#10;    }&#10;&#10;    void DemonstrateDynamicConfiguration(JFM::TextureConfigManager&amp; configManager) {&#10;        JFM_INFO(&quot;\n--- 动态注册配置 ---&quot;);&#10;&#10;        // 创建自定义配置&#10;        JFM::TextureSpecification customSpec;&#10;        customSpec.MinFilter = JFM::TextureFilter::NearestMipmapLinear;&#10;        customSpec.MagFilter = JFM::TextureFilter::Nearest;&#10;        customSpec.WrapS = JFM::TextureWrap::MirroredRepeat;&#10;        customSpec.WrapT = JFM::TextureWrap::MirroredRepeat;&#10;        customSpec.GenerateMips = true;&#10;&#10;        // 注册自定义配置&#10;        configManager.RegisterConfig(&quot;custom_retro&quot;, customSpec);&#10;        JFM_INFO(&quot;注册自定义配置 'custom_retro'&quot;);&#10;&#10;        // 验证配置是否存在&#10;        if (configManager.HasConfig(&quot;custom_retro&quot;)) {&#10;            auto retrievedSpec = configManager.GetConfig(&quot;custom_retro&quot;);&#10;            JFM_INFO(&quot;验证成功 - 自定义配置已注册&quot;);&#10;        }&#10;    }&#10;&#10;    void DemonstrateSaveConfiguration(JFM::TextureConfigManager&amp; configManager) {&#10;        JFM_INFO(&quot;\n--- 保存配置到文件 ---&quot;);&#10;&#10;        std::string outputPath = &quot;Engine/Assets/texture_config_output.txt&quot;;&#10;        bool saved = configManager.SaveConfigToFile(outputPath);&#10;        JFM_INFO(&quot;配置保存结果: {}&quot;, saved ? &quot;成功&quot; : &quot;失败&quot;);&#10;&#10;        if (saved) {&#10;            JFM_INFO(&quot;配置已保存到: {}&quot;, outputPath);&#10;        }&#10;    }&#10;};&#10;&#10;// 应用程序类&#10;class TextureConfigApp : public JFM::Application {&#10;public:&#10;    TextureConfigApp() {&#10;        PushLayer(std::shared_ptr&lt;JFM::Layer&gt;(new TextureConfigDemo()));&#10;    }&#10;&#10;    ~TextureConfigApp() = default;&#10;};&#10;&#10;// 客户端入口点&#10;JFM::Application* JFM::CreateApplication() {&#10;    return new TextureConfigApp();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>